"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSrcFiles = void 0;
/* eslint-disable max-lines */
const path_1 = require("path");
const process = __importStar(require("process"));
const junk_1 = require("junk");
const precinct_1 = __importDefault(require("precinct"));
const semver_1 = __importDefault(require("semver"));
const non_nullable_js_1 = require("../../../../utils/non_nullable.js");
const included_files_js_1 = require("../../utils/included_files.js");
const package_json_js_1 = require("../../utils/package_json.js");
const traversal_cache_js_1 = require("../../utils/traversal_cache.js");
const list_imports_js_1 = require("./list_imports.js");
const resolve_js_1 = require("./resolve.js");
const traverse_js_1 = require("./traverse.js");
const tree_files_js_1 = require("./tree_files.js");
const tree_shake_js_1 = require("./tree_shake.js");
// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const getSrcFiles = async function ({ config, featureFlags, mainFile, name, pluginsModulesPath, srcDir, srcPath, stat, }) {
    const { includedFiles = [], includedFilesBasePath } = config;
    const { exclude: excludedPaths, paths: includedFilePaths } = await (0, included_files_js_1.getPathsOfIncludedFiles)(includedFiles, includedFilesBasePath);
    const [treeFiles, depFiles] = await Promise.all([
        (0, tree_files_js_1.getTreeFiles)(srcPath, stat),
        getDependencies({ featureFlags, functionName: name, mainFile, pluginsModulesPath, srcDir }),
    ]);
    const files = [...treeFiles, ...depFiles].map(path_1.normalize);
    const uniqueFiles = [...new Set(files)];
    // We sort so that the archive's checksum is deterministic.
    // Mutating is fine since `Array.filter()` returns a shallow copy
    const filteredFiles = uniqueFiles.filter(isNotJunk).sort();
    const includedPaths = (0, included_files_js_1.filterExcludedPaths)([...filteredFiles, ...includedFilePaths], excludedPaths);
    return includedPaths;
};
exports.getSrcFiles = getSrcFiles;
// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
    return (0, junk_1.not)((0, path_1.basename)(file));
};
// Retrieve all the files recursively required by a Node.js file
const getDependencies = async function ({ featureFlags, functionName, mainFile, pluginsModulesPath, srcDir, }) {
    const packageJson = await (0, package_json_js_1.getPackageJson)(srcDir);
    const state = (0, traversal_cache_js_1.getNewCache)();
    try {
        return await getFileDependencies({
            featureFlags,
            functionName,
            path: mainFile,
            packageJson,
            pluginsModulesPath,
            state,
        });
    }
    catch (error) {
        error.message = `In file "${mainFile}"\n${error.message}`;
        throw error;
    }
};
const paperwork = async (path) => {
    if (semver_1.default.lt(process.version, '18.0.0')) {
        return await precinct_1.default.paperwork(path, { includeCore: false });
    }
    // for Node v18, we're temporarily using our own mechanism to filter out core dependencies, until
    // https://github.com/dependents/node-precinct/pull/108 landed
    const modules = await precinct_1.default.paperwork(path, { includeCore: true });
    return modules.filter((moduleName) => {
        if (moduleName.startsWith('node:')) {
            return false;
        }
        // only require("node:test") refers to the
        // builtin, require("test") doesn't
        if (moduleName === 'test') {
            return true;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const isNativeModule = moduleName in process.binding('natives');
        return !isNativeModule;
    });
};
const getFileDependencies = async function ({ featureFlags, functionName, path, packageJson, pluginsModulesPath, state, treeShakeNext = false, }) {
    if (state.localFiles.has(path)) {
        return [];
    }
    state.localFiles.add(path);
    const basedir = (0, path_1.dirname)(path);
    const dependencies = featureFlags.parseWithEsbuild ? await (0, list_imports_js_1.listImports)({ functionName, path }) : await paperwork(path);
    const depsPaths = await Promise.all(dependencies.filter(non_nullable_js_1.nonNullable).map((dependency) => getImportDependencies({
        dependency,
        basedir,
        featureFlags,
        functionName,
        packageJson,
        pluginsModulesPath,
        state,
        treeShakeNext,
    })));
    return depsPaths.flat();
};
const getImportDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency);
    if ((0, tree_shake_js_1.shouldTreeShake)(dependency, shouldTreeShakeNext)) {
        return getTreeShakedDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext: shouldTreeShakeNext,
        });
    }
    return (0, traverse_js_1.getDependencyPathsForDependency)({ dependency, basedir, state, packageJson, pluginsModulesPath });
};
const isNextOnNetlify = function (dependency) {
    return (0, path_1.basename)(dependency, '.js') === 'renderNextPage';
};
// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = async function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const path = await (0, resolve_js_1.resolvePathPreserveSymlinks)(dependency, [basedir, pluginsModulesPath].filter(non_nullable_js_1.nonNullable));
    const depsPath = await getFileDependencies({
        featureFlags,
        functionName,
        path,
        packageJson,
        pluginsModulesPath,
        state,
        treeShakeNext,
    });
    return [path, ...depsPath];
};
/* eslint-enable max-lines */
//# sourceMappingURL=src_files.js.map